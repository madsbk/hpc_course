#include <iostream>
#include <cmath>
#include <vector>
#include <random>
#include <H5Cpp.h>
#include <chrono>
#include <argparse.hpp>

// SI units: Newtons constant of gravity, Solar Mass, distance from Earth to Sun (AU), and JPL unit of velocity, AU/day
const double G = 6.673e-11;
const double SOLAR_MASS = 1.98892e30;
const double AU = 149597870700;
const double AD = AU / (24. * 3600.);

/** Class that represents a body, which can be a sun, a planet, or an asteroid */
class Body {
public:
    // The mass of the body
    double mass;
    // The position of the body in the x, y, and z axis
    double pos_x;
    double pos_y;
    double pos_z;
    // The velocity of the body in the x, y, and z axis
    double vel_x;
    double vel_y;
    double vel_z;
};

/** Class that represent a solar system, which consist of a sun, some planets, and many asteroids. */
class SolarSystem {
public:
    // The first Body is the sun and the rest are planets
    std::vector<Body> sun_and_planets;
    std::vector<Body> asteroids;
};

/** Function that returns the Kepler velocity -- corresponding to a body in a circular orbit */
double kepler_velocity(double pos_x, double pos_y, double pos_z) {
    double r = std::sqrt(pos_x * pos_x + pos_y * pos_y + pos_z * pos_z);
    return std::sqrt(G * SOLAR_MASS / r);
}

/** Return a new random solar system
 *
 * @param num_of_asteroids The number of asteroids
 * @param seed             The random seed the use
 * @return                 The new solar system
 */
SolarSystem random_system(uint64_t num_of_asteroids, uint64_t seed) {
    std::mt19937 gen(seed);
    std::uniform_real_distribution<double> random_real(0, 1);

    // Solar System Ephemerides generated by JPL Horizon system for 13-02-2021 00:00 TDB (barycentric time!)
    // (0,0,0) is set at the center of mass for the Solar System, which is not at the center of the Sun
    // Sun
    double mass = SOLAR_MASS;
    double pos_x = -6.939120887892797E-3*AU; double pos_y =  5.747188451007198E-3*AU; double pos_z =  1.148384057799366E-4*AU;
    double vel_x = -6.544433519666372E-06*AD; double vel_y = -6.172720711215085E-06*AD; double vel_z =  2.101452452998284E-07*AD;
    Body the_sun = Body{mass, pos_x, pos_y, pos_z, vel_x, vel_y, vel_z};
    std::vector<Body> sun_and_planets = {the_sun}; // The first body is the sun
    // Mercury
    mass = SOLAR_MASS / 6023682.;
    pos_x = -3.489435534060263E-01*AU; pos_y =  1.198095410068464E-01*AU; pos_z =  4.080789837136244E-02*AU;
    vel_x = -1.472289494295207E-02*AD; vel_y = -2.549472074554867E-02*AD; vel_z = -7.326786621442656E-04*AD;
    sun_and_planets.push_back(Body{mass, pos_x, pos_y, pos_z, vel_x, vel_y, vel_z});
    // Venus
    mass = SOLAR_MASS / 408523.72;
    pos_x =  3.581712636091036E-01*AU; pos_y = -6.235356522141564E-01*AU; pos_z = -2.958988935951608E-02*AU;
    vel_x =  1.735247476983314E-02*AD; vel_y =  1.007432834238533E-02*AD; vel_z = -8.631657907430781E-04*AD;
    sun_and_planets.push_back(Body{mass, pos_x, pos_y, pos_z, vel_x, vel_y, vel_z});
    // Earth
    mass = SOLAR_MASS / 332946.0487;
    pos_x = -8.078442505231266E-01*AU; pos_y =  5.831320274468754E-01*AU; pos_z =  9.273772511744191E-05*AU;
    vel_x = -1.035103163864096E-02*AD; vel_y = -1.403326698993734E-02*AD; vel_z =  1.019838772702252E-06*AD;
    sun_and_planets.push_back(Body{mass, pos_x, pos_y, pos_z, vel_x, vel_y, vel_z});
    // Mars
    mass = SOLAR_MASS / 3098703.59;
    pos_x =  5.433407676778666E-02*AU; pos_y =  1.568439781218769E+00*AU; pos_z =  3.135948622597734E-02*AU;
    vel_x = -1.346015687592686E-02*AD; vel_y =  1.729635176008936E-03*AD; vel_z =  3.666138547700492E-04*AD;
    sun_and_planets.push_back(Body{mass, pos_x, pos_y, pos_z, vel_x, vel_y, vel_z});
    // Jupiter
    mass = SOLAR_MASS / 1047.56549688;
    pos_x =  3.284755554859510E+00*AU; pos_y = -3.864876891397587E+00*AU; pos_z =  -5.745522202367392E-02*AU;
    vel_x =  5.656797807092814E-03*AD; vel_y =  5.243733492952428E-03*AD; vel_z = -1.483174252349262E-04*AD;
    sun_and_planets.push_back(Body{mass, pos_x, pos_y, pos_z, vel_x, vel_y, vel_z});
    // Saturn
    mass = SOLAR_MASS / 3498.76667474;
    pos_x =  5.669212821032890E+00*AU; pos_y = -8.202584462326351E+00*AU; pos_z =  -8.307987098803682E-02*AU;
    vel_x =  4.278650561361220E-03*AD; vel_y =  3.157963341369132E-03*AD; vel_z = -2.250710871565522E-04*AD;
    sun_and_planets.push_back(Body{mass, pos_x, pos_y, pos_z, vel_x, vel_y, vel_z});
    // Uranus
    mass = SOLAR_MASS / 22905.3426;
    pos_x =  1.523494497890529E+01*AU; pos_y =  1.259053595876394E+01*AU; pos_z =  -1.506088277844468E-01*AU;
    vel_x = -2.534304435254144E-03*AD; vel_y =  2.848473830050199E-03*AD; vel_z =   4.326056025806510E-05*AD;
    sun_and_planets.push_back(Body{mass, pos_x, pos_y, pos_z, vel_x, vel_y, vel_z});
    // Neptune
    mass = SOLAR_MASS / 19416.3129471;
    pos_x =  2.947625865563749E+01*AU; pos_y = -5.092058884278901E+00*AU; pos_z = -5.744488884613864E-01*AU;
    vel_x =  5.139497530346715E-04*AD; vel_y =  3.112318538936126E-03*AD; vel_z = -7.589746140797978E-05*AD;
    sun_and_planets.push_back(Body{mass, pos_x, pos_y, pos_z, vel_x, vel_y, vel_z});

    // Place asteroids in a belt from 2 to 3.5 AU
    // Only put them first quadrant to appreciate differential rotation
    std::vector<Body> asteroids;
    for (uint64_t i = 0; i < num_of_asteroids; ++i) {
        double dist = AU * (2. + 1.5 * random_real(gen));
        double theta = M_PI / 2 * random_real(gen);
        double pos_x = dist * std::cos(theta);
        double pos_y = dist * std::sin(theta);
        double pos_z = (random_real(gen) - 0.5) * .1 * dist;

        double v_kep = kepler_velocity(pos_x, pos_y, pos_z);
        double vel_x = -1 * std::sin(theta) * v_kep;
        double vel_y = std::cos(theta) * v_kep;
        double vel_z = 0;
        // Mass of Ceres is roughly 1e21 kg, in reality mass distribution is a broken power-law
        double mass = random_real(gen) * 1e21 + 1e14;
        asteroids.push_back(Body{mass, pos_x, pos_y, pos_z, vel_x, vel_y, vel_z});
    }

    return SolarSystem{sun_and_planets, asteroids};
}

/** Update the velocity of `a` based on `b`
 *
 * @param a  The body to update
 * @param b  The body which act on `a`
 * @param dt The time step size
 */
void update_velocity(Body &a, const Body &b, double dt) {
    // Euclidean distance
    double r = std::sqrt((b.pos_x - a.pos_x) * (b.pos_x - a.pos_x)
                       + (b.pos_y - a.pos_y) * (b.pos_y - a.pos_y)
                       + (b.pos_z - a.pos_z) * (b.pos_z - a.pos_z));

    // Acceleration:  A = ((G m_b)/r^2)*((x_b-x_a)/r)
    double A = (G * b.mass / (r*r)); // Acceleration without direction

    // Update velocity of `a`
    a.vel_x += A * ((b.pos_x - a.pos_x) / r) * dt;
    a.vel_y += A * ((b.pos_y - a.pos_y) / r) * dt;
    a.vel_z += A * ((b.pos_z - a.pos_z) / r) * dt;
}

/** Kick a set of bodies forward in time due to their mutual gravitational interaction
 *
 * @param a  The bodies to update
 * @param dt The time step size
 */
void kick_same(std::vector<Body> &a, const double dt) {
    uint64_t n = a.size();
    for (uint64_t i = 0; i < n; i++) {
        for (uint64_t j = 0; j < n; j++) {
            if (i != j) {
                update_velocity(a[i], a[j], dt);
            }
        }
    }
}

/** Kick a set of bodies forward in time due to gravitational interaction with another set of bodies
 *
 * @param a  The bodies to update
 * @param b  The bodies that perturb
 * @param dt The time step size
 */
void kick_other(std::vector<Body> &a, const std::vector<Body> &b, const double dt) {
    uint64_t n = a.size();
    uint64_t m = b.size();
    for (uint64_t i = 0; i < n; ++i) {
        for (uint64_t j = 0; j < m; ++j) {
            update_velocity(a[i], b[j], dt);
        }
    }
}

/** Drift a set of bodies forward in time
 *
 * @param bodies The bodies to update
 * @param dt     The time step size
 */
void drift(std::vector<Body> &bodies, const double dt) {
    for (Body &body: bodies) {
        body.pos_x += body.vel_x * dt;
        body.pos_y += body.vel_y * dt;
        body.pos_z += body.vel_z * dt;
    }
}

/** Integrate one time step of the solar system
 *
 * @param solar_system  The solar system to update
 * @param dt            The time step size
 */
void integrate(SolarSystem &solar_system, double dt) {

    // Kick is done twice --> only half dt each time
    double const hdt = 0.5*dt;
    // First kick
    // Update velocity of all bodies
    kick_same(solar_system.sun_and_planets, hdt);
    kick_other(solar_system.asteroids,solar_system.sun_and_planets, hdt);

    // Drift: Update position of all bodies
    drift(solar_system.sun_and_planets, dt);
    drift(solar_system.asteroids, dt);

    // Second kick
    // Update velocity of all bodies
    kick_same(solar_system.sun_and_planets, hdt);
    kick_other(solar_system.asteroids,solar_system.sun_and_planets, hdt);

}

/** Write data to a hdf5 file
 *
 * @param group  The hdf5 group to write in
 * @param name   The name of the data
 * @param shape  The shape of the data
 * @param data   The data
 */
void write_hdf5(H5::Group &group, const std::string &name, const std::vector<hsize_t> &shape,
                const std::vector<double> &data) {

    H5::DataSpace dataspace(static_cast<int>(shape.size()), &shape[0]);
    H5::DataSet dataset = group.createDataSet(name.c_str(), H5::PredType::NATIVE_DOUBLE, dataspace);
    dataset.write(&data[0], H5::PredType::NATIVE_DOUBLE);
}

/** Write the solar system to a hdf5 file (use `visual.py` to visualize the hdf5 data)
 *
 * @param solar_systems  The solar system to write
 * @param filename       The filename to write to
 */
void write_hdf5(const std::vector<SolarSystem> &solar_systems, const std::string &filename) {

    H5::H5File file(filename, H5F_ACC_TRUNC);

    for (uint64_t i = 0; i < solar_systems.size(); ++i) {
        H5::Group group(file.createGroup("/" + std::to_string(i)));
        {
            std::vector<double> data;
            for (const Body &body: solar_systems[i].sun_and_planets) {
                data.push_back(body.mass);
            }
            write_hdf5(group, "sun_and_planets_mass", {solar_systems[i].sun_and_planets.size()}, data);
        }
        {
            std::vector<double> data;
            for (const Body &body: solar_systems[i].sun_and_planets) {
                data.push_back(body.pos_x);
            }
            for (const Body &body: solar_systems[i].sun_and_planets) {
                data.push_back(body.pos_y);
            }
            for (const Body &body: solar_systems[i].sun_and_planets) {
                data.push_back(body.pos_z);
            }
            write_hdf5(group, "sun_and_planets_position", {3, solar_systems[i].sun_and_planets.size()}, data);
        }
        {
            std::vector<double> data;
            for (const Body &body: solar_systems[i].asteroids) {
                data.push_back(body.pos_x);
            }
            for (const Body &body: solar_systems[i].asteroids) {
                data.push_back(body.pos_y);
            }
            for (const Body &body: solar_systems[i].asteroids) {
                data.push_back(body.pos_z);
            }
            write_hdf5(group, "asteroids_position", {3, solar_systems[i].asteroids.size()}, data);
        }

    }
}

/** N-body Solar System simulation
 *
 * @param num_of_iterations  Number of iterations
 * @param num_of_asteroids   Number of asteroids
 * @param seed               Random seed
 * @param filename           Filename to write each time step to. If empty, do data is written.
 */
void simulate(uint64_t num_of_iterations, uint64_t num_of_asteroids, uint64_t seed,
              uint64_t every, const std::string &filename) {
    double dt = 1e5;
    SolarSystem system = random_system(num_of_asteroids, seed);
    std::vector<SolarSystem> systems;
    systems.push_back(system);
    auto begin = std::chrono::steady_clock::now();
    for (uint64_t i = 0; i < num_of_iterations; ++i) {
        integrate(system, dt);
        if (!filename.empty() && (i % every) == 0) {
            systems.push_back(system);
        }
    }
    if (!filename.empty()) {
        write_hdf5(systems, filename);
    }
    auto end = std::chrono::steady_clock::now();
    std::cout << "elapsed time: " << (end - begin).count() / 1000000000.0 << " sec"<< std::endl;
    std::cout << "Performance: " << (end - begin).count() / 
        (num_of_iterations * (1 + 8 + num_of_asteroids)) << " nanosecs / particle update"<< std::endl;
}

/** Main function that parses the command line and start the simulation */
int main(int argc, char **argv) {
    util::ArgParser args(argc, argv);
    int64_t iterations, every, num_of_asteroids, seed;
    if (args.cmdOptionExists("--iter")) {
        iterations = std::stoi(args.getCmdOption("--iter"));
        if (iterations < 0) {
            throw std::invalid_argument("iter most be a positive integer (e.g. --iter 100)");
        }
    } else {
        throw std::invalid_argument("You must specify the number of iterations (e.g. --iter 100)");
    }
    if (args.cmdOptionExists("--every")) {
        every = std::stoi(args.getCmdOption("--every"));
        if (every < 0) {
            throw std::invalid_argument("every most be a positive integer (e.g. --every 10)");
        }
    } else {
        every = 10;
    }
    if (args.cmdOptionExists("--asteroids")) {
        num_of_asteroids = std::stoi(args.getCmdOption("--asteroids"));
        if (num_of_asteroids < 0) {
            throw std::invalid_argument("asteroids most be a positive integer (e.g. --asteroids 1000)");
        }
    } else {
        throw std::invalid_argument("You must specify the number of asteroids (e.g. --asteroids 1000)");
    }
    if (args.cmdOptionExists("--seed")) {
        seed = std::stoi(args.getCmdOption("--seed"));
        if (seed < 0) {
            throw std::invalid_argument("Seed most be a positive integer (e.g. --seed 42)");
        }
    } else {
        seed = std::random_device{}(); // Default seed is taken from hardware
    }
    const std::string &filename = args.getCmdOption("--out");
    if (!filename.empty()) {
        std::cout << "Writing data to " << filename << std::endl;
        std::cout << "Writing out every " << every << "th iteration to disk (--every "<< every << ")" << std::endl;
    }

    simulate(static_cast<uint64_t>(iterations), 
             static_cast<uint64_t>(num_of_asteroids),
             static_cast<uint64_t>(seed),
             static_cast<uint64_t>(every),
             filename);
    return 0;
}
